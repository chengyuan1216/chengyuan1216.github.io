<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../index.css">
    <script src="../babel.js"></script>
    <script>

    </script>
</head>
<body >

<div class="box">
    <h3>let</h3>
    <p>
        let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
    </p>
    <h4>let定义的变量一定要先声明再使用。</h4>
    <ol>
        <li>
            <strong>只在let命令所在的代码块内有效。</strong>
            <pre>
        {
            var a=12;
            let b=13;
        }
        console.log(a)//12
        console.log(b)//b is not defined
            </pre>
        </li>
        <li>
            <strong>for循环中i的值的问题</strong>
            <pre>
        /* for中i的问题 */
        for(let i=0; i<2; i++ ){

        }
        console.log(i)//i is not defined

        //在es6之前对i的使用都是同一个值
        var a = [];
        var b = [];
        function num(i){
            return i;
        }
        for(var i=0; i<10; i++){
            a[i] = i;
            b[i] = num(i);
        }
        console.log(a[6]());//10,因为i是一个全局变量，所以输出的均为10。
        console.log(b[6]);//6，通过给函数赋值的形式，保存i的每一个值。


        //变量i是let声明的，当前的i只在本轮循环有效，
        //所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。
        var c = [];
        for(let i=0; i<10; i++){
            c[i] = i;
        }
        console.log(c[6]);//6
            </pre>
        </li>
        <li>
            <strong>for循环设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</strong>
            <pre>
        for(let i=0; i<3; i++){
            let i = 123;
            console.log(i);//输出3遍123
        }
            </pre>
        </li>

        <li>
            <strong>let定义的变量不存在变量提升。</strong>
            <pre>
        let a = 12;
        console.log(a);//12

        console.log(b);//undefined
        var b = 132;

        console.log(c);//b is not defined
        let c = 132;
            </pre>
        </li>
        <li>
            <strong>不能在同一个作用域内重复声明同一个变量。</strong>
        </li>
   </ol>

    <h3>块级作用域</h3>
    <ol>
        <li>
            <strong>块级作用域</strong>
            在es6之前只有全局作用域和函数作用域。
            <pre>
        function f1() {
            let n = 5;
            if (true) {
                let n = 10;
            }
            console.log(n); // 5
        }
        f1()

        function f2() {
            let n = 5;
            if (true) {
                let n = 10;
                console.log(n); // 10
            }
        }
        f2()
            </pre>
        </li>
        <li>
            <strong>允许块级作用域的任意嵌套。</strong>
            <p>
                外层作用域无法读取内层作用域的变量。 <br/>
                内层作用域可以定义外层作用域的同名变量。
            </p>
        </li>
        <li>
            <strong>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</strong>
        </li>
        <li>
            <strong>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</strong>
        </li>
    </ol>


    <h3>const</h3>
    <p>
        const声明一个只读的常量。一旦声明，常量的值就不能改变。
    </p>

    <pre>
        const a = 12;
        a = 13;
        console.log(a);//Assignment to constant variable.
    </pre>

    <ol>
        <li><strong>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</strong></li>
        <li><strong>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</strong></li>
        <li>
            <strong>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</strong>
            对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。<br/>
            但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，
            至于它指向的数据结构是不是可变的，就完全不能控制了。
            <pre>
        const obj = {};
        obj.name = "hh"
        console.log(obj.name);//hh

        //这里虽然声明了一个常量，但常量保存的是对象的引用地址
        //也就是说obj不能再指向别的对象了，但对象本身却可以变化
            </pre>
            如果想把一个对象冻结。
            <pre>
        //obj指向的对象将不能更改。
        const obj = Object.freeze({});

        //将一个对象的属性也冻结
        var constantize = (obj) => {
          Object.freeze(obj);
          Object.keys(obj).forEach( (key, i) => {
            if ( typeof obj[key] === 'object' ) {
              constantize( obj[key] );
            }
          });
        };
            </pre>
        </li>
    </ol>

    <h3>es6声明变量的6中方法</h3>
    <p>
        var、function、let、const、import、class
    </p>

    <h3>顶层对象的属性与全局变量</h3>
    <p>
        ES6 规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；
        另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
    </p>
</div>
</body>
</html>