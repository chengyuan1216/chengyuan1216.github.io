<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../index.css">
    <script src="../babel.js"></script>
    <script  type="text/babel">
    </script>
</head>
<body >

<div class="box">
    <h3>简介</h3>
    <p>
        es6之前定义一个对象是： <br/>
        1、定义构造函数<br/>
        2、定义原型对象<br/>
    </p>
    <p>
        基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
    </p>
    <p>
        <strong>语法糖</strong>
        指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。
    </p>

    <h4>对比两种写法</h4>
    <p>
        1、es6的写法将构造函数和原型对象都放在class Point{}内部。 <br/>
        2、constructor()是构造函数，而定义的其他函数都是方法。<br/>
        3、定义构造函数，方法时不需要加function。<br/>
    </p>
    <pre>
        //es6之前
        function Point(x, y) {
          this.x = x;
          this.y = y;
        }

        Point.prototype.toString = function () {
          return '(' + this.x + ', ' + this.y + ')';
        };

        var p = new Point(1, 2);

        //es6
        <strong>class</strong> Point {
          <strong>constructor</strong>(x, y) {
            this.x = x;
            this.y = y;
          }

          toString() {
            return '(' + this.x + ', ' + this.y + ')';
          }
        }

        //es6定义class的格式
        class className {
            constructor(){}
            method1{}
            method2{}
        }
    </pre>
    <mark>ES6 的类，完全可以看作构造函数的另一种写法。</mark>
    <pre>
        class Point {
          // ...
        }

        typeof Point // "function"
        Point === Point.prototype.constructor // true
        <strong>
            es6的class写法本质上与之前的构造函数加原型对象一样。
        </strong>
    </pre>

    <h4>采用class定义的方法都是原型方法，所以如果要给class添加方法可以通过原型。</h4>
    <h4>采用class定义的方法都是不可枚举的，而用原来的方式定义的话是可枚举的。</h4>
    <h4>类的属性名，可以采用表达式。</h4>
    <pre>
        let methodName = 'getArea';

        class Square {
          constructor(length) {
            // ...
          }

          [methodName]() {
            // ...
          }
        }
    </pre>
    <h4>类和模块的内部，默认是严格模式.</h4>

    <h4>定义class</h4>
    <mark>constructor</mark>
    <p>
        constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。
        一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
    </p>
    <p>
        <strong>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</strong>
    </p>
    <p>
        可以通过实例的__proto__属性为“类”添加方法。
        实例的__proto__属性指向class的原型。

    </p>

    <h4>类的表达式</h4>

    <pre>
        const MyClass = class Me {
          getClassName() {
            return Me.name;
          }
        };

        let inst = new MyClass();

        inst.getClassName() // Me

        Me.name // ReferenceError: Me is not defined

        <strong>注意Me只能在内部使用，如果用不到Me可省略。</strong>

        const MyClass = class { /* ... */ };

        <strong>也可写出立即执行的class</strong>
        let person = new class {
          constructor(name) {
            this.name = name;
          }

          sayName() {
            console.log(this.name);
          }
        }('张三');
    </pre>

    <h4>不存在变量提升，必须先定义类在使用。</h4>

    <h4>定义私有方法</h4>
    <pre>
        const bar = Symbol('bar');
        const snaf = Symbol('snaf');

        export default class myClass{

          // 公有方法
          foo(baz) {
            this[bar](baz);
          }

          // 私有方法
          [bar](baz) {
            return this[snaf] = baz;
          }

          // ...
        };
    </pre>

    <h4>在类中定义访问器属性</h4>
    <pre>
        class MyClass {
            constructor() {
                this.name = "张三";
                console.log("constructor");
            }
            get prop() {
                return this.name;
            }
            set prop(value) {
                this.name = value;
            }
        }

        let inst = new MyClass();
        console.log(inst.prop);
        inst.prop = "李四";
        console.log(inst.prop);
    </pre>

    <h4>class的静态方法</h4>
    <p>
        如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
        <br/>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。
        <br/>
        静态方法是直接定义在类对象上的，所以类创造的实例是无法访问的。
        <br/>
        但是可以被子类继承。
    </p>

    <h4>new.target属性</h4>
    <p>
        ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。
    </p>
    <pre>
        function Person(name) {
          if (new.target !== undefined) {
            this.name = name;
          } else {
            throw new Error('必须使用 new 命令生成实例');
          }
        }
    </pre>

    <h3>例子</h3>
    <pre>
        class Point{
            constructor(x,y){
                this.x = x;
                this.y = y;
                if( new.target === Point){
                    this.sayX = function(){
                        alert(this.x);
                        //这个方法不会添加到原型对象上
                        //这个方法将不会被子类继承
                    }
                }
            }

            sayY(){
                alert(this.y);
            }

            static hello(){
                alert("hello");
            }
        }

        class Ppoint extends Point{

        }

        let p = new Point(100, 100);
        //p.sayX();//100
        //p.sayY();//100
        Point.hello();//hello

        let pp = new Ppoint(200, 200);
        //pp.sayY();//200
        //pp.sayX();//报错
        Ppoint.hello();//hello

        //alert(p.constructor.prototype.hasOwnProperty("sayX"))//false
        //alert(p.constructor.prototype.hasOwnProperty("sayY"))//true
    </pre>
</div>
</body>
</html>