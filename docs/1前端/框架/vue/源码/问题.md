# 数据篇
### Observer
- 1、Dep、Observer、Watcher三者之间的联系？依赖收集的过程？使用了什么设计模式？
- 2、Observer内部是怎样对数组进行处理的？针对支持`__proto__`和不支持`__proto__`的运行环境是怎么分别处理的？
- 3、为什么要使用`$set`给对象新增属性？ 为什么不能给组件data对象添加根属性?

### Dep
- 作用是什么？

### Watcher
- 1、Watcher可以分为哪三类？
- 2、为什么`computed watcher`要懒计算？
- 3、`computed`属性缓存计算结果是怎么实现的？
- 4、`computed`属性依赖变化了会立即重新计算值吗？是同步的还是异步的？
- 5、`computed`使用`deep`时做了什么特殊处理？
- 6、`render watcher`执行时是异步的吗？
- 7、

### Computed
- 1、实现原理？
```js
const computedWatcher = new Watcher(vm, userGetter/*定义的computed get函数*/)
Object.defineProperty(vm, 'computedKey', {
    get() {
        return computedWatcher.value
    }
})
```
- 2、怎样设置`computed`不缓存结果, 就算依赖未发生变化也重新计算？
- 3、假设计算属性b依赖组件数据`data.a`, 那么当`data.a`改变时是怎么通知到使用了计算属性b的watcher的？

### beforeCreate
- beforCreate之前做了哪些事情？
- 在beforeCreate能访问到data、perops、computed吗？为什么？
- beforeCreate的使用场景？

### created
- beforCreate和created之间做了哪些事情？

# 任务调度篇
### nextTick
- 作用是什么？
- nextTick是使用什么方式来做到异步处理任务队列的？是怎样做到优雅降级的？
- 能否自己实现一个nextTick？

### queueWatcher(render Watcher 队列)
- 作用是什么？
- 为什么要异步更新renderWatcher？
- 为什么要使用队列？而不是每个renderWatcher都直接使用nextTick? nextTick本身已经有自己的队列了, 能够保证同步加入nextTick的wathcer能够在
    同一轮异步任务中执行。

# 视图篇
### beforeMount
- 什么时候执行的？

### renderWathcer
- 作用？
- vnode是什么？

### render
- 作用？
- 组件第一次执行render方法是什么时候？
- 使用vnode的优势？劣势？

### 组件
- 第一次渲染是同步还是异步？ 第二次以后呢？
- vm.$scopedSlots？(todo)

- vm._vnode和vm.$vnode分别是什么？
















































