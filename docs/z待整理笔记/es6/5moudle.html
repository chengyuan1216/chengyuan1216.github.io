<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../index.css">
    <script src="../babel.js"></script>
    <script src="main.js" type="module"></script>
    <script src="module1.js" type="module"></script>
    <script type="text/babel" >

    </script>
</head>
<body >

<div class="box">
    <h3>什么是模块？？</h3>
    <p>
        在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。
        前者用于服务器，后者用于浏览器。
        ES6 在语言标准的层面上，实现了模块功能，
        而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
    </p>
    <p>
        根据模块的加载方式，可分为运行时加载、编译时加载。
    </p>
    <p>
        ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
        ES6 模块就是编译时加载。
    </p>
    <p>
        模块功能主要由两个命令构成：export和import。
        export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
    </p>

    <p>
        一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。
        如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。
    </p>

    <h3>严格模式</h3>
    <p>
        ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。
    </p>

    <h3>export</h3>
    <p>
        export命令可以出现在模块的任何位置，只要处于模块顶层就可以。
        如果处于块级作用域内，就会报错，下一节的import命令也是如此。
        这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。
    </p>
    <pre>
        var firstName = 'Michael';
        var lastName = 'Jackson';
        var year = 1958;
        //输出变量
        export {firstName, lastName, year};

        export var a = 13;

        //输出函数
        export function multiply(x, y) {
          return x * y;
        };



        // 报错
        var m = 1;
        export m;
        //正确的想法
        // 写法一
        export var m = 1;

        // 写法二
        var m = 1;
        export {m};

        // 写法三
        var n = 1;
        export {n as m};//改名字后输出
    </pre>

    <h3>import命令</h3>
    <p>
        import命令具有提升效果，会提升到整个模块的头部，首先执行。
    </p>
    <pre>
        //从profile.js模块引入指定的变量
        import {firstName, lastName, year} from './profile.js';

        //重命名变量
        import { lastName as surname } from './profile.js';

        //仅仅执行lodash模块，但是不输入任何值。
        //如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
        import 'lodash';

        //所有输出值都加载在这个circle对象上面。
        import * as circle from './circle';
    </pre>

    <h3>export default 命令</h3>
    <p>
        export default命令其实只是输出一个叫做default的变量
    </p>
    <pre>
        // export-default.js 输出匿名函数
        export default function () {
          console.log('foo');
        }

        // import-default.js  加载模块时可指定名称
        import customName from './export-default';
        customName(); // 'foo'
    </pre>

    <p>
        如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。
    </p>
    <pre>
        export default function (obj) {
          //
        }

        export function each(obj, iterator, context) {
          //
        }


        import _, each from 'lodash';
    </pre>
    <p>
        export default也可以用来输出类。
    </p>
    <pre>
        // MyClass.js
        export default class { ... }

        // main.js
        import MyClass from 'MyClass';
        let o = new MyClass();
    </pre>

    <h3>export 与 import 的复合写法</h3>
    <pre>
        export { foo, bar } from 'my_module';

        // 等同于
        import { foo, bar } from 'my_module';
        export { foo, bar };
    </pre>


    <h3>模块的继承</h3>
    <p>
        就是将一个模块引进，在这个模块的输出的基础上改动，然后输出一个新的模块。
    </p>

    <h3>跨模块常量</h3>
    <p>
        就是在一个模块中定义好一些常量，然后在要使用的模块内引入。
    </p>

    <h3>import() </h3>
    <p>
        import语句是在编译时解析，所以不能再运行时动态的加载模块。
        因为import语句只能在顶层作用域内。
        因此，有一个提案，建议引入import()函数，完成动态加载。
    </p>
    <p>
        import()，返回一个promise对象。 <br/>
        import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。
    </p>
    <pre>
        //按需加载
        button.addEventListener('click', event => {
          import('./dialogBox.js')
          .then(dialogBox => {
            dialogBox.open();
          })
          .catch(error => {
            /* Error handling */
          })
        });

        //条件加载
        if (condition) {
          import('moduleA').then(...);
        } else {
          import('moduleB').then(...);
        }
    </pre>

   <h3>js加载的方式</h3> <br/>
    <mark>1、传统方式</mark>
    <p>
        默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到script标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。
    </p>
    <pre>
        &lt!-- 页面内嵌的脚本 -->
        &ltscript type="application/javascript">
          // module code
        &lt/script>

        &lt!-- 外部脚本 -->
        &ltscript type="application/javascript" src="path/to/myModule.js">
        &lt/script>
    </pre>

    <mark>2、异步加载</mark>
    <p>
        script标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。
    </p>
    <p>
        <strong>defer与async的区别是：</strong>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
    </p>
    <pre>
        &ltscript src="path/to/myModule.js" defer>&lt/script>
        &ltscript src="path/to/myModule.js" async>&lt/script>
    </pre>

    <mark>3、模块加载</mark>
    <p>
        有两点要注意：1、type="module"  2、默认是defer。
    </p>
    <pre>
        &ltscript type="module" src="./foo.js">&lt/script>
        &lt!-- 等同于 -->
        &ltscript type="module" src="./foo.js" defer>&lt/script>

        //内嵌网页中
        &ltscript type="module">
          import utils from "./utils.js";

          // other code
        &lt/script>
    </pre>
    <mark>4、node加载es6模块</mark>

    <h3>ES6 模块与 CommonJS 模块的差异</h3>
    <ol>
        <li>
            <strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong>
            <p>
                CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
                ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
            </p>
        </li>
        <li>
            <strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong>
            <p>是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
        </li>
    </ol>
</div>
</body>
</html>