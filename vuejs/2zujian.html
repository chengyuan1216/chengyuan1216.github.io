<!DOCTYPE html>
<html xmlns:v-on="http://www.w3.org/1999/xhtml">
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../index.css">
    <script src="../vue.min.js"></script>
</head>
<body >
<div class="box">
    <h3>1、组件的定义</h3>
    <ul>
        <li>
            组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。
        </li>
        <li>
            在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。
        </li>
        <li>
            非常类似于自定义元素，但又有很大的不同。
        </li>
        <li>
            组件可以扩展 HTML 元素，封装可重用的代码。 <br/>
            在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。 <br/>
        </li>
        <li>
            <strong>
                在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。
                给原生元素添加is="组件名"
            </strong>
        </li>
    </ul>

    <h3>2、定义、注册组件</h3>
    <ol>
        <li>
            定义组件，就是通过Vue.extend()扩展得到的组件对象。需要传入配置参数定义。
        </li>
        <li>
            注册组件，就是在组件内部或全局注册已经定义好的组件。
            组件只有注册之后才能使用。
            使用时只需在与Vue实例挂接的容器内部使用。
        </li>
    </ol>

    <p>
        <mark>注册全局组件：</mark>  <br/>
    </p>
    <pre>
        //注册组件
        Vue.component("组件名", {
            props:"",
            data:""'
            template:""
        })
    </pre>
    <pre>
    // 定义名为 todo-item 的新组件
    Vue.component('todo-item', {
        template: '&ltli>这是个待办项&lt/li>'
    })

     //使用的组件
     &lttodo-item>&lt/todo-item>
    </pre>

    <ul id="demo1">
        <my-component v-for="it in text"  v-bind:item ="it"></my-component>
    </ul>
    <script>
        Vue.component("my-component",{
            props:["item"],
            data:function(){
                return {
                    msg:"定义的组件的内部data必须是函数返回。"
                }
            },
            template:"<li>{{item}}{{msg}}</li>"
        })

        new Vue({
            el:"#demo1",
            data:{
                text:["html","css","js"]
            }
        })

    </script>

    <pre>

        /*
        v-bind:item ="it" 的用处是将父组件的数据穿给子组件
        */
        &ltul id="demo1">
            &ltmy-component v-for="it in text"  v-bind:item ="it">&lt/my-component>
        &lt/ul>

        /*
        子组件想要获取付组件的数据，必须通过子组件的属性来获取。
        */
        Vue.component("my-component",{
            props:["item"],
            template:"&ltli>{{item}}&lt/li>"
        })


        new Vue({
            el:"#demo1",
            data:{
                text:["html","css","js"]
            }
        })
    </pre>

    <mark>局部注册</mark><br/>
    不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：

    <div id="demo10">
        <my-component></my-component>
    </div>

    <script>
        var Child = {
            data:function(){
                return {
                    a:"我是局部组件"
                }
            },
            template:"<h5>{{a}}haha</h5>"
        };

        new Vue({
            el:"#demo10",
            components: {
                'my-component': Child
            }
        })
    </script>

    <pre>
        &ltdiv id="demo10">
            &ltmy-component>&lt/my-component>
        &lt/div>

        /* 子组件的配置 */
        var Child = {
            data:function(){
                return {
                    a:"我是局部组件"
                }
             },
            template:"&lth5>{{a}}haha&lt/h5>"
        };

        new Vue({
            el:"#demo10",
            /*
            注册子组件，注意这里是components。
            注册格式是，组件名：配置。
            */
            components: {
                'my-component': Child
            }
        })
    </pre>

    <mark>另一种注册的方式</mark><br/>
    其实呢，Vue.component()会调用Vue.extend()。所以两种方式都是一样的。
    <pre>
        var Aaa = Vue.extend({
            data;function(){
                return{
                    msg:"hello word"
                }
            },
            template:"&lth1>{{msg}}&l/h1>"
        });

        Vue.component('aaa',Aaa);//全局组件
    </pre>

    <h3>3、定义模板的方式</h3>
    <mark>1. 字符串形式</mark><br/>
    template:'&lth2 @click="change">标题2->{{msg}}&lt/h2>' <br/>
    像前面的例子一样直接定义。<br/><br/>

    <mark>2. 单独放到某个地方 </mark>
    <h4>用法：单独定义，使用id关联，template:"模版id"。</h4>
    <pre>
    //在script标签内定义
    &ltscript type="x-template" id="aaa">
        &lth2 @click="change">标题2->{{msg}}&lt/h2>
    &lt/script>

    //在标签template内定义
    &lttemplate id="aaa">
        &lth1>标题1&lt/h1>
        &ltul>
            &ltli v-for="val in arr">
                {{val}}
            &lt/li>
        &lt/ul>
    &lt/template>

    Vue.extend({
        template:"#aaa"
    })
    </pre>


    <h3>4、动态组件</h3>

    <p>
        通过使用保留的 <strong>component</strong> 元素，动态地绑定到它的 <strong>is </strong> 特性，我们让多个组件可以使用同一个挂载点，并动态切换。
    </p>
    <p>
        如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。
        为此可以添加一个 keep-alive 指令参数
    </p>

    <pre>
        &ltkeep-alive>
          &ltcomponent :is="currentView">
            &lt!-- 非活动组件将被缓存！ -->
          &lt/component>
        &lt/keep-alive>

        &ltcomponent <strong>v-bind:is="currentView"</strong>>
            &lt!-- 组件在 vm.currentview 变化时改变！ -->
        &lt/component>

        var vm = new Vue({

              el: '#example',

              data: {
                currentView: 'home'
              },

              components: {
                home: { /* ... */ },
                posts: { /* ... */ },
                archive: { /* ... */ }
              }

        })
    </pre>

    <div id="app">
        <button @click="change">切换</button>
        <component :is="name"></component>
    </div>

    <script>
        var component1 = Vue.extend({
            template:"<h4>我是组件一</h4>"
        })

       var component2 = Vue.extend({
            template:"<h4>我是组件二</h4>"
       })

       Vue.component("a1",component1);
       Vue.component("a2",component2);

        new Vue({
            el:"#app",
            data:{
                name:"a1"
            },
            methods:{
                change:function(){
                    this.name=="a1"?this.name="a2":this.name="a1";
                }
            }
        })

    </script>

    <pre>
    &ltdiv id="app">
        &ltbutton @click="change">切换&lt/button>
        &ltcomponent :is="name">&lt/component>
    &lt/div>



       var component1 = Vue.extend({
            template:"&lh4>我是组件一&l/h4>"
       })

       var component2 = Vue.extend({
            template:"&lh4>我是组件二&l/h4>"
       })

       Vue.component("a1",component1);
       Vue.component("a2",component2);

        new Vue({
            el:"#app",
            data:{
                name:"a1"
            },
            methods:{
                change:function(){
                    this.name=="a1"?this.name="a2":this.name="a1";
                }
            }
        })
    </pre>


    <h3>5、子组件索引</h3>
    <p>
        可以使用 <strong>ref</strong> 为子组件指定一个索引 ID。
    </p>
    <p>
        $refs 只在组件渲染完成后才填充，并且它是非响应式的。
        它仅仅作为一个直接访问子组件的应急方案——应当避免在模板或计算属性中使用 $refs。
    </p>

    <pre>
        &ltdiv id="parent">
          &ltuser-profile ref="profile">&lt/user-profile>
        &lt/div>

        var parent = new Vue({ el: '#parent' })
        // 访问子组件
        var child = parent.$refs.profile
    </pre>


    <h3>6、异步组件</h3>
    <p>
        Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。
        Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。
    </p>

    <pre>
        Vue.component('async-example', function (resolve, reject) {

          setTimeout(function () {
            //成功时
            resolve({
              template: '&ltdiv>I am async!&lt/div>'
            })
          }, 1000)

        })
    </pre>


    <h1>例子：</h1>
    <h4>组件内部嵌套组件</h4>
    <h4>在父组件的内定义时要确定自子组件已定义并且要在父组件内部注册调用。错误的用法是在模板中使用一个不是在父组件内定义的组件。</h4>
    <div id="ex1" >
        <app2></app2>
        <app1></app1>
    </div>

    <template id="inner">
        <div style="color:red">这里是内部组件</div>
    </template>

    <template id="outer">
        <div style="border: 1px solid #ccc;width:200px;">
            外部组件内部
            <inner-component></inner-component>
        </div>
    </template>

    <script>
        //定义内部部组件
        var Inner = {template: '#inner'};

        //定义外部组件
        var  Outer = {
            template: '#outer',
            components: {
                // 注册定义好的内部组件
                'inner-component': Inner
            }
        };

        // 注册父组件
        Vue.component('app2', Outer);
        //复用子组件。
        Vue.component('app1', Inner);

        var vm = new Vue({
            el:"#ex1",
            data:{

            }
        });
    </script>


    <pre>
    &ltdiv id="ex1" >
        &ltapp2>&lt/app2>
        &ltapp1>&lt/app1>
    &lt/div>

    &lttemplate id="inner">
        &ltdiv style="color:red">这里是内部组件&lt/div>
    &lt/template>

    &lttemplate id="outer">
        &ltdiv style="border: 1px solid #ccc;width:200px;">
            外部组件内部
            &ltinner-component>&lt/inner-component>
        &lt/div>
    &lt/template>


        //定义内部部组件
        var Inner = {template: '#inner'};

        //定义外部组件
        var  Outer = {
            template: '#outer',
            components: {
                // 注册定义好的内部组件
                'inner-component': Inner
            }
        };

        // 注册父组件
        Vue.component('app2', Outer);
        //复用子组件。
        Vue.component('app1', Inner);

        var vm = new Vue({
            el:"#ex1",
            data:{

            }
        });


    </pre>

</div>

</body>
</html>
