<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../index.css">
    <script src="../index.js"></script>
    <script src="../babel.js"></script>
    <script>

    </script>
</head>
<body >

<div class="box">
    <h3>什么是结构赋值？</h3>
    <p>
        ES6 允许按照一定模式，<strong>从数组和对象中提取值</strong>，对变量进行赋值，这被称为解构（Destructuring）。
    </p>
    <p>
        顾名思义，就是以一种与源数据的数据结构相同的模式去匹配对应位置的数据。
        模式是一组变量的组织。
    </p>
    <h3>数组的解构赋值 </h3>
    <p>
        先来一个简单的例子。同时给abc赋值。
    </p>
    <pre>
        var [a, b, c] = [1, 2, 3];
        console.log(a, b, c)//1 2 3

        //你可以认为[a, b, c]是匹配模式,同时定义了三个变量
        //[1, 2, 3]是源数据
    </pre>
    <p>
        本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
    </p>
    <pre>
        var [ a, [b, [c, d] ] ]= [ 1, [ 2, [3, 4] ] ];
        console.log(a,b,c,d)//1 2 3 4
        模式匹配规则必须和源数据的格式一致

        var[ a, b ] =  [ 1, [ 2, [3, 4] ] ];
        console.log(b)//[2, Array(2)]
        如果你想获取的是源数据的一个属性对象，那你不必分析这个对象的内部数据结构

        var [ , , b ] = [1,2,3];
        console.log(b)//3
        对不想要的部分用逗号隔开，表示这里还有一个不需要的值
    </pre>

    <p>
        特别说明的是。"..."，表示一个数组。
    </p>
    <pre>
        var [ , ...arr ] = [1,2,3 ,4];
        console.log(arr) // [2, 3, 4]
        //只能在在后一个位置这样使用，将后面的数据组成一个数组返回

        var [a, b] = [1]
        console.log(b)//undefined
        //如果解构不成功，返回undefined

        var [a] = [1,2,3]
        //不完全解构
    </pre>
    <p>
        <strong>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong>
    </p>
    <mark>指定默认值</mark>
    <p>
        指定默认值就是说，如果源数据对应的数据时undefined，那么你给的默认值才会生效。
    </p>
    <p>
        如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
    </p>
    <p>
        默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
    </p>
    <pre>
       let [a, b=12] = [1, 2]
       console.log(a, b)//1 2  这里b=12没有生效

       let [a, b=12] = [1, undefined]
       console.log(a, b)//1 12
       //只有当一个数组成员严格等于undefined，默认值才会生效。

       let [a, b=12] = [1, null]
       console.log(a, b)//1 null

       let [x = 1, y = x] = [];     // x=1; y=1
    </pre>

    <h3>对象的结构赋值</h3>
    <p>
        对象的解构与数组有一个重要的不同。
        数组的元素是按次序排列的，变量的取值 <strong>由它的位置决定</strong>；
        而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值。
    </p>
    <p>
        如果解构不成功，返回undefined
    </p>
    <p>
        <strong>注意：对象结构赋值里，匹配模式和变量的区别。</strong>
    </p>
    <p>
        默认值生效的条件是，对象的属性值严格等于undefined。
        如果解构失败，变量的值等于undefined。
    </p>
    <p>
        如果对象没有对应的实例方法，解构的可能是对象的原型方法。
    </p>
    <pre>
        //let { bar, foo } = { foo: "aaa", bar: "bbb" };
        //console.log(bar, foo)// bbb aaa
        //变量名必须与源对象的属性名一样

        //如果变量名与属性名不一致，必须写成下面这样。
        let { bar:b , foo:f } = { foo: "aaa", bar: "bbb" };
        console.log(b ,f)//bbb aaa
        //真正赋值的是b和f，bar和foo是匹配模式。
        //第一个例子是 let { bar:bar , foo:foo }的简写

        let obj = {
            p: [
                'Hello',
                { y: 'World' }
            ]
        };
        let { p: [x, { y }] } = obj;
        console.log(x, y)//Hello World
        console.log(p)// p is not defined。p是模式不是变量。
    </pre>

    <p>
        <strong>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</strong>
    </p>
    <pre>
        // 错误的写法
        let x;
        {x} = {x: 1};

        // 正确的写法
        let x;
        ({x} = {x: 1});
    </pre>

    <mark>将一个数组结构赋值给一个对象</mark>
    <p>
        由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
    </p>
    <pre>
        let arr = [1, 2, 3];
        let {0 : first, [arr.length - 1] : last} = arr;
        first // 1
        last // 3
    </pre>

    <mark>对象结构赋值的用法</mark>
    <p>
        对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
    </p>
    <pre>
        let { log, sin, cos } = Math;
        //获取Math对象的三个方法引用
    </pre>

    <h3>字符串解构赋值</h3>
    <p>
        字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
    </p>

    <pre>
        let [a, b, c, d, e] = 'hello';
        console.log(a, b, c, d, e)//h e l l o

        let [ , , ...arr] = 'hello';
        console.log(arr);//  ["l", "l", "o"]  可以实现slice()的功能

        let {0:first, length:len} = "world";
        console.log(first, len)//w 5
    </pre>

    <h3>数值和布尔值的解构赋值</h3>
    <p>
        解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
    </p>
    <p>
        解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
    </p>
    <pre>
        let {toString: s1} = 123;
        s1 === Number.prototype.toString // true
        //先将123转化成new Number(123),toString方法是Number对象的原型的属性。

        let {toString: s2} = true;
        s2 === Boolean.prototype.toString // true
    </pre>

    <h3>函数参数的解构赋值</h3>
    <p>
        将解构赋值运用到函数的参数。函数的参数也可以使用解构赋值。
    </p>
    <pre>
        function add([x, y]){
            console.log(x + y);
        }

        add([1, 2]);//3
    </pre>

    <p>
        <strong>参数也可以使用默认值。</strong>
    </p>
    <pre>
        //设置默认值
        //另一种方式[x = 0, y = 0] = []???
        //这种方式有问题，如果xy都没有赋值没问题
        //但如果只有x或y的话将得不到结果
        function add( [x, y] = [0,0] ){
            console.log(x + y);
        }
        add();//0
        add([100, 200]);//300
        add([100])//100

    </pre>


    <h3>解构赋值的用途</h3> <br/>
    <mark>互换变量的值</mark>
    <pre>
        let x = 12;
        let y = 16;

        [y ,x] = [x, y];
        console.log(x,y)//16 32

        let a = {a:5};
        let b = {b:55};
        console.log(a.a, b.b) // 5  55
        [b,a] = [a,b]
        //console.log(a.a, b.b)// 报错
        //如果引用的是对象会报错
    </pre>

    <mark>提取json对象的数据</mark>
    <p></p>
    <mark>函数参数的默认值</mark>
    <pre>
        jQuery.ajax = function (url, {
          async = true,
          beforeSend = function () {},
          cache = true,
          complete = function () {},
          crossDomain = false,
          global = true,
          // ... more config
        }) {
          // ... do stuff
        };
    </pre>

    <mark>输入模块的指定方法</mark>
    <pre>
        const { SourceMapConsumer, SourceNode } = require("source-map");
    </pre>
</div>
</body>
</html>