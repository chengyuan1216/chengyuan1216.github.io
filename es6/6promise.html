<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="../index.css">
    <script src="../index.js" charset="UTF-8"></script>
    <script src="../babel.js"></script>
    <script>
    </script>
</head>
<body >

<div class="box">
    <h3>1、什么是promise?</h3>
    <p>
        所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
    </p>

    <h3>2、promise的特点</h3>
    <ol>
        <li>
            <strong>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</strong>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
        </li>
        <li>
            <strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</strong>
            Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
        </li>
        <li>
           <strong>缺点：</strong>
            <ul>
                <li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
                <li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
                <li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
            </ul>
        </li>
    </ol>

    <h3>3、基本用法</h3>
    <p>
        ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
    </p>
    <mark>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，它们是两个函数。</mark>
    <p>
        如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。
        resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
    </p>
    <pre>
        const promise = new Promise(function(resolve, reject){
            // 内部代码解决什么样的情况下promise的状态该如何变化
            var message = "promise的状态变为fulfilled";
            var error = "promise的状态变为rejected";
            var control;
            setTimeout(function(){

                control = (Math.random()<0.5)?true:false;

                if(control){// 如果异步操作成功
                    resolve(message);//pending --> fulfilled
                }else{
                    reject(error);//pending --> rejected
                }

            },1000);
        });
    </pre>
    <mark>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</mark>
    <p>
        第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。
    </p>

    <pre>
        promise.then(function(value){
            //成功状态调用的代码
            alert(value);
        },function(err){
            //失败状态调用的代码
            alert(err);
        });
    </pre>
    <mark>Promise 新建后就会立即执行。</mark>
    <p>
        then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。
        Promise对象本身提供的也是一个异步操作。
    </p>
    <pre>
        let promise = new Promise(function(resolve, reject) {
            console.log('Promise');
            resolve();// 改变状态后将异步执行回调函数
        });

        promise.then(function() {
            console.log('resolved.');
        });

        console.log('Hi!');
        //结果：
        // Promise
        // Hi!
        // resolved
    </pre>

    <p>
        一个异步加载图片的例子。
    </p>
    <pre>
        function loadImageAsync(url) {
            return new Promise(function(resolve, reject) {
                const image = new Image();

                image.onload = function() {
                    resolve(image);
                };

                image.onerror = function() {
                    reject(new Error('Could not load image at ' + url));
                };

                image.src = url;
            });
        }

        loadImageAsync("image").then(null,function(err){
            alert(err);//Error: Could not load image at image
        })
    </pre>
    <p>
        下面是一个用Promise对象实现的 Ajax 操作的例子。
    </p>
    <pre>
        const getJSON = function(url) {
            const promise = new Promise(function(resolve, reject){
                const handler = function() {
                    if (this.readyState !== 4) {
                        return;
                    }
                    if (this.status === 200) {
                        resolve(this.response);
                    } else {
                        reject(new Error(this.statusText));
                    }
                };
                const client = new XMLHttpRequest();
                client.open("GET", url);
                client.onreadystatechange = handler;
                client.responseType = "json";
                client.setRequestHeader("Accept", "application/json");
                client.send();

            });

            return promise;
        };

        getJSON("/posts.json").then(function(json) {
            console.log('Contents: ' + json);
        }, function(error) {
            console.error('出错了', error);
        });
    </pre>
    <mark>resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例。</mark>
    <p>
        这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。
    </p>
    <pre>
        const p1 = new Promise(function (resolve, reject) {
            // ...
        });

        const p2 = new Promise(function (resolve, reject) {
            // ...
            resolve(p1);
        })
    </pre>

    <pre>
        let p1 = new Promise(function(resolve,reject){
            setTimeout(function(){
                reject(new Error('fail'));
            },3000);
        });
        let p2 = new Promise(function(resolve,reject){
            resolve(p1)
        });

        p2.then(function(result){
            alert(result);
        },function(err){
            alert(err);//error : fail 三秒后执行
        })
    </pre>
    <p>
        <strong>有疑问！！！！！</strong>
        p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。
        <strong>也就是说resolve方法会返回改变了状态的promise对象本身，但如果resolve方法的参数是另一个promise的话，将返回参数promise。</strong>
    </p>

    <pre>
        var p1 = new Promise(function(resolve,reject){
            setTimeout(function(){
                resolve("rejected");
            },3000);
        });
        var p2 = new Promise(function(resolve, reject){
                resolve(p1);
        });
        p2.then(function(value){
            alert(value)
        },function(err){
            alert(err)
        });
    </pre>


    <h3>4、Promise.prototype.then() </h3>
    <p>
        then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。
    </p>

    <mark>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）</mark>
    <pre>
        new Promise(function(resolve, reject){
            resolve("hello");
        })
        .then(function(v){
            console.log(1,v)
            return "world";
            //如果没有返回值将默认将undefined传给下一个promise
        },function(v){
            console.log(1,v)
        })
        .then(function(v){
            console.log(3,v)
        },function(v){
            console.log(4,v)
        })

        //        1 "hello"
        //        3 "world"
        //由此可知，Promise的状态由前一个传递给了下一个
    </pre>
    <h4>后面的Promise是否一定是与前一个的状态一样呢？？</h4>
    <pre>
        new Promise(function(resolve, reject){
            resolve("resolved");
        })
        .then(function(v){      //resolve
            console.log(v);
            return new Promise(function(resolve, reject){
                reject("rejected")
            });
            //等这个Promise的状态改变后下一个then才会执行
        })
        .then(null,function(v){  //reject
             console.log(v);
        }).then(function(v){   //resolve,
                                // 上一个是rejected,但这里并不是和上一个一样。
                                // 未手动改变 的始终和第一个一样。
             console.log("resolved");
        });
        //resolved
        //rejected
        //resolve
        // 由此可知可以通过上一个Promise来改便下一个Promise的状态，但也只是改变一个而已。
        //如果不手动改变，则下一个Promise的状态会和第一个一样。
    </pre>

    <h3>5、Promise.prototype.catch() </h3>
    <p>
        Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
    </p>
    <pre>
        new Promise(function(resolve, reject){
            resolve();
        })
        .then(function(){       //resolve
            console.log(1)
            return new Promise(function(resolve, reject){
                reject();
            });
        },function(){
            console.log(2);
        })
        .then(function(){       //reject
           console.log(3)
        },function(){
           console.log(4)
        })
        .then(function(){       //resolve
           console.log(5);
        },function(){
           console.log(6)
        })
        .catch(function(){     //resolve
           console.log("出错了！！")
        })
        //1
        //4
        //5
        //出错了！！
    </pre>

    <p>
        catch还有捕获错误的作用。比纯粹的只能识别
    </p>
    <pre>
        const promise = new Promise(function(resolve, reject) {
            throw new Error('test');
        });
        promise.catch(function(error) {
            console.log(error);
        });
        //Error: test

        //与下面的写法等价
        // 写法一
        const promise = new Promise(function(resolve, reject) {
          try {
            throw new Error('test');
          } catch(e) {
            reject(e);
          }
        });
        promise.catch(function(error) {
          console.log(error);
        });

        // 写法二
        const promise = new Promise(function(resolve, reject) {
          reject(new Error('test'));
        });
        promise.catch(function(error) {
          console.log(error);
        });
    </pre>

    <pre>
        new Promise(function(resolve, reject){
           throw new Error('test');
        }).then(null, function(error){
           console.log(2,error);//2 Error: test
       });

        new Promise(function(resolve, reject){
            resolve();
        })
        .then(function(){
             throw new Error("error1");
              //中间任何位置抛出错误都能被获取到
        })
        .then(function(){
             throw new Error("error2");//不执行
        })
        .catch(function(error){
            console.log(2,error);//2 Error: error1
        });
    </pre>
    <strong>上面两个列子说明抛出错会主动执行reject函数。</strong>

    <h3>6、Promise.all()</h3>
    <strong>这是一个静态方法。</strong>
    <p>
        用于将多个 Promise 实例，包装成一个新的 Promise 实例。
    </p>
    <pre>
        const p = Promise.all([p1, p2, p3]);
    </pre>
    <p>
        p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。
    </p>
    <strong>
        p的状态由p1、p2、p3决定。如果p1、p2、p3的状态都是成功，那么p的状态也是成功。
        只要其中一个是失败，那么p的状态就是失败。
    </strong>
    <pre>
        let p1 = new Promise(function(resolve, reject){
            setTimeout(function(){
                var control = (Math.random()<0.5)?true:false;
                if(control){
                    resolve("p1的结果是成功");
                }else{
                    reject("p1的结果是失败");
                }
            },10000);
        });
        let p2 = new Promise(function(resolve, reject){
            setTimeout(function(){
                var control = (Math.random()<0.5)?true:false;
                if(control){
                    resolve("p2的结果是成功");
                }else{
                    reject("p2的结果是失败");
                }
            },20000);
        });

        p1.then(function(v){
            console.log(v);
        }).catch(function(v){
            console.log(v);
        })

        p2.then(function(v){
            console.log(v);
        }).catch(function(v){
            console.log(v);
        })

        Promise.all([p1,p2]).then(function(){
            console.log("恭喜你做的很好");
        }).catch(function(){
            console.log("请再接再厉");
        });
    </pre>
    <p>
        如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。
    </p>

    <h3>7、Promise.race()</h3>
    <p>
        同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
    </p>
    <p>
        只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。
        那个率先改变的 Promise 实例的resolve或reject的参数，就传递给p的回调函数。
    </p>
    <p>
        不管是那个promise改变了状态，Promise.race([p1,p2])的状态都会改变。
    </p>

    <pre>
        let p1 = new Promise(function(resolve, reject){
            setTimeout(function(){
                var control = (Math.random()<0.5)?true:false;
                if(control){
                    resolve("p1的结果是成功");
                }else{
                    reject("p1的结果是失败");
                }
            },10000);
        });
        let p2 = new Promise(function(resolve, reject){
            setTimeout(function(){
                var control = (Math.random()<0.5)?true:false;
                if(control){
                    resolve("p2的结果是成功");
                }else{
                    reject("p2的结果是失败");
                }
            },20000);
        });

        p1.then(function(v){
            console.log(v);
            return "p1"
        }).catch(function(v){
            console.log(v);
            return "p1"
        })

        p2.then(function(v){
            console.log(v);
            return "p2"
        }).catch(function(v){
            console.log(v);
            return "p2"
        })

        Promise.race([p1, p2]).then(function(v){
            console.log("race"+v);//racep1的结果是。。
        }).catch(function(v){
            console.log("race"+v);
        })
    </pre>

    <h3>8、Promise.resolve()</h3>
    <p>
        有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。
    </p>
    <strong>用法：</strong>
    <ol>
        <li>
            <strong>参数是一个 Promise 实例。</strong>
            如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。
        </li>
        <li>
            <strong>参数是一个thenable对象。</strong>
            thenable对象指的是具有then方法的对象。
            Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
            <pre>
                let thenable = {
                  then: function(resolve, reject) {
                    resolve(42);
                  }
                };

                let p1 = Promise.resolve(thenable);
                p1.then(function(value) {
                  console.log(value);  // 42
                });
            </pre>
        </li>
        <li>
            <strong>参数不是具有then方法的对象，或根本就不是对象</strong>
            如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。
        </li>
        <li>
            <strong>不带有任何参数。</strong>
            Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。
        </li>
    </ol>

    <h3>9、Promise.reject()</h3>
    <p>
        Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
    </p>
    <p>
        用法与Promise.resolve()一样。
    </p>

    <h3>10、done()</h3>
    <p>
        Promise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。
    </p>

    <h3>11、finally()</h3>
    <p>
        finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。
    </p>


    <h3>12、promise实现</h3>
    <ol>
        <li>调用回调函数的两种情况：调用resolve、reject时 或 promise状态已经变化立即执行回调。 </li>
    </ol>
    <pre>
        function promise(fn){
            //定义三个常量描述状态
            const PENDING = 0;
            const FULFILLED = 1;
            const REJECTED = 2;

            let callbacks = {};//存储回调函数，只有FULFILLED、REJECTED两个属性
            let value = null;//promise给resolve或reject的参数
            let status = PENDING;//初始状态

            let number = 0;//记录resolve、reject执行的次数，只能是0,1
            let isAsyn = false;//判断是否异步执行resolve 、reject 内部的函数。

            function resolve( val ){
                if( number == 0 ){
                    if(!isAsyn){   //如果是不是异步执行resolve函数，将让他异步执行。
                        setTimeout(function(){
                            status = FULFILLED;//改变状态
                            value = val;//给下一个promise传递参数
                            callbacks[status](value);//执行对应状态的回调函数
                            number++;
                        },0)
                    }else{
                        status = FULFILLED;//改变状态
                        value = val;//给下一个promise传递参数
                        callbacks[status](value);//执行对应状态的回调函数
                        number++;
                    }
                }
            }

            function reject(val){
                if( number == 0 ){
                    if(!isAsyn) {
                        setTimeout(function(){
                            status = REJECTED;
                            value = val;
                            callbacks[status](value);//执行对应状态的回调函数
                            number++;
                        },0)
                    }else{
                        status = REJECTED;
                        value = val;
                        callbacks[status](value);//执行对应状态的回调函数
                        number++;
                    }
                }
            }

           this.then = function( onFULFILLED, onREJECTED ){
                if( status == PENDING){//状态未改变
                    //将函数添加到回调
                    if( onFULFILLED && typeof onFULFILLED === "function" ){
                        callbacks[FULFILLED] = onFULFILLED;
                    }

                    if( onREJECTED && typeof onREJECTED === "function" ){
                        callbacks[REJECTED] = onREJECTED;
                    }

//                    return new promise(function(resolve, reject){
//                        resolve();
//                    });
                    //返回一个PENDING状态的promise，是为了能调用then方法。
                    //如果一开始的状态是PENDING，等前一个的promise状态改变后
                    //可以再返回一个状态一样的promise来替代他

                    //问题是：怎么调用另一个promise的回调函数呢？？？???????
                    //原生Promise默认返回的一个FULFILLED的Promise,所以不存在这个问题。

                }else{

                    callbacks[status](value);//执行对应状态的回调函数

                }

            }

            fn(resolve, reject);//对外提供的接口

            isAsyn = true;

        }

        var p = new promise(function(resolve, reject){
            setTimeout(function(){

            },3000);
            resolve("hello");
        });

        p.then(function(val){
            alert(val);//数据传递？？？
        },function(){

        });

    </>
</div>
</body>
</html>